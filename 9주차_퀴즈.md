# 9주차 퀴즈

### 1. 지네릭스가 정의에 대해 설명하고 아래 예시를 지네릭스 변경하면서 지네릭스의 장점에 대해 설명해주세요.(선민)
```java
class Box {
  Object item;

  void setItem(Object item) {this.item = item;}
  Object getItem() {return item;}
}
```

<br></br>
답변)

- 지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능으로 
다룰 객체의 타입을 미리 명시해준다.
  <br>
```java
class Box<T> {
    T item;
    
    void setItem(T item){ this.item = item; }
    T getItem() { return item; }
}
```
<br>

- 지네릭스의 장점
    1. 타입 안정성을 제공한다. : 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다는 뜻이다. <br><br>
    2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.

<br></br>

### 2. static 멤버에 지네릭스의 타입 변수를 참조할 수 없는 이유에 대해 설명해주세요(선민)
답변)<br>
지네릭스는 인스턴스별로 다르게 동작하도록 만든 기능이다. 그래서 T 는 인스턴스 변수로 간주된다. static 멤버는 모든 객체에 대해 동일하게 동작해야하므로 인스턴스변수로 취급되는 T 를 참조할 수 없다.

<br></br>


### 3. 아래 O / X 퀴즈를 풀어주세요(선민)
- 지네릭스 타입을 다르게 하면 메서드 오버로딩을 할 수 있다 (O / X)
- ? 와일드 카드는 어떠한 타입도 될 수 있어 Object 타입과 유사하다고 볼 수 있다 (O / X)
- 지네릭 메서드는 메서드 선언부에 지네릭 타입이 선언된 메서드를 말한다 (O / X)
- 서로 관련된 상수를 편리하게 선언하기 위한 것은 열거형이다 (O / X)

답변)<br>
- 지네릭스 타입을 다르게 하면 메서드 오버로딩을 할 수 있다 (X) -> 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않는다
- ? 와일드 카드는 어떠한 타입도 될 수 있어 Object 타입과 유사하다고 볼 수 있다 (O)
- 지네릭 메서드는 메서드 선언부에 지네릭 타입이 선언된 메서드를 말한다 (O)
- 서로 관련된 상수를 편리하게 선언하기 위한 것은 열거형이다 (O)


<br></br>


### 4. 지네릭 타입의 기본적인 제거 과정을 설명하세요.(민아)

<br></br>

### 5. 다음 빈칸에 들어갈 Enum클래스에 정의된 메서드를 작성하세요.(민아)
|메서드|설명|
|:-----:|-----|
||열거형의 Class 객체를 반환한다.|
||열거형 상수의 이름을 문자열로 반환한다.|
||지정된 열거형에서 name과 일치하는 열거형 상수를 반환한다.|

<br></br>

### 6. 에너테이션의 정의와 장점에 대해 설명하세요.(민아)
답변)<br>
'애너테이션'은 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것을 말합니다.<br>
주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있습니다.

<br></br>

### 7. 다음 코드가 에러가 발생하는 이유와 해결 방법을 설명하세요. (지영) 
```java

static Juice makeJuice(FruitBox<Fruit> box){
  String tmp ="";
  for(Fruit f : box.getList() ) tmp += f + " ";
  return new Juice(tmp);
}
static Juice makeJuice(FruitBox<Apple> box){
  String tmp ="";
  for(Fruit f : box.getList() ) tmp += f + " ";
  return new Juice(tmp);
}

```

<br></br>

답변) 
<br></br>
하지만 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문에(해당 코드는 메서드 중복정의), 와일드 카드를 사용해야한다.



```java
static Juice makeJuice(FruitBox<? extends Fruit> box){
  String tmp ="";
  for(Fruit f : box.getList() ) tmp += f + " ";
  return new Juice(tmp);
}
```
따라서 위와 같은 코드를 이용하여 사용해야한다.

<br></br>

### 8. 메서드 앞에 `@Override`라고 애너테이션을 붙이는 이유에 대해 설명하세요. (지영)

<br></br>

### 9. 애너테이션의 요소를 선언할 때 반드시 지켜야 하는 규칙 4가지를 설명하세요.(지영)

<br></br>

### 10. 다음과 같이 지네릭 클래스 Box가 선언되어 있을 때, 지네릭스 용어를 설명하세요.(성훈)

```
class Box<T>
```

<br></br>

답변)

- 지네릭스의 용어
```
Box<T>  지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.
T       타입변수 또는 타입 매개변수.(T는 타입 문자) - T말고 다른 타입 변수들이 있다.
Box     원시타입(raw type)
```
<br></br>

### 11. 다음 지네릭 메서드에 대해 설명하세요. (성훈)

```
public static <T extends Comparable<? super T>> void sort(List<T> list)
```

<br></br>

### 12. 열거형의 정의와 사용법을 설명하세요.(성훈)

<br></br>

### 13. 와일드 카드에 대해서 설명하시오.(기훈)

<br>

### 14. 모든 열거형의 조상을 적으시오. (기훈)

<br>

### 15. 애너테이션에 대해 설명하시오. (기훈)

<br>

### 16. 지네릭에 대한 설명응로 틀린 것은 무엇입니까?(현수)
1. 컴파일 시 강한 타입 체크를 할 수 있다.
2. 타입변환(casting)을 제거한다.
3. 지네릭 타입은 타입 파라미터를 가지는 지네릭 클래스와 인터페이스를 말한다.
4. 지네릭 메소드는 리턴 타입으로 타입 파라미터를 가질 수 없다. 

<br></br>

### 17. ContainerExample 클래스의 main() 메소드는 Container 지네릭 타입을 사용하고 있습니다. main() 메소드에서 사용하는 방법을 참고해서 Container 지네릭 타입을 선언해보세요.(현수)

```java
public class ContainerExample {
 
    public static void main(String[] args) {
        Container<String> container1 = new Container<> ();
        container1.set("홍길동");
        String str = container1.get();
        
        Container<Integer> container2 = new Container<>();
        container2.set(6);
        int value = container2.get();
    }
}
```

<br></br>

### 18. ContainerExample 클래스의 main() 메소드는 Container 지네릭 타입을 사용하고 있습니다. main() 메소드에서 사용하는 방법을 참고해서 Container 지네릭 타입을 선언해보세요.(현수)

```java
public class ContainerExample {
 
    public static void main(String[] args) {
        Container<String, String> container1 = new Container<> ();
        container1.set("홍길동", "도적");
        String name = container1.getKey();
        String job = container1.getValue();
        
        Container<String , Integer> container2 = new Container<>();
        container2.set("홍길동", 35);
        String name2 = container2.getKey();
        int age = container2.getValue();
    }
}
```

<br></br>

