### 1. 4가지 접근제어자(public, private, default, protected) 에 대해 설명해주세요.(선민)

<br></br>

### 2. 아래 코드의 실행 결과를 설명해주세요.(선민)
```java
public class Main {
    
    public static void main(String[] args) {
        Parent p = new Child();
        
        System.out.println("p.name = " + p.name);
        p.printName();
    }
}

class Parent {
    String name = "parent";
    
    public void printName() {
        System.out.println("Parent 클래스의 메서드입니다.");
        System.out.println(this.name);
    }
}

class Child extends Parent {
    String name = "child";
    
    public void printName() {
        System.out.println("Child 클래스의 메서드입니다.");
        System.out.println(this.name);
    }
}
```

객체 생성과 타입 참조
Parent p = new Child(); 이 코드는 Child 클래스의 인스턴스를 생성하고, 이 인스턴스를 Parent 타입의 참조 변수 p로 참조합니다. 여기서 Child 클래스는 Parent 클래스를 상속받습니다. 이로 인해 Child 클래스의 객체는 Parent 클래스의 속성과 메서드를 모두 상속받습니다.

필드 접근
System.out.println("p.name = " + p.name); 이 구문을 실행하면 p.name이 출력됩니다. p는 Parent 타입으로 선언되었기 때문에, Java의 필드 접근은 참조 변수의 선언된 타입(Parent)을 기준으로 결정됩니다. 따라서 여기서는 Parent 클래스의 name 필드 값인 "parent"가 출력됩니다.

메서드 호출
p.printName(); 코드에서 printName() 메서드를 호출합니다. Java에서는 메서드 호출이 런타임에 결정되는 동적 바인딩을 사용합니다. p는 실제로 Child 객체를 참조하고 있기 때문에 Child 클래스의 printName() 메서드가 호출됩니다.
Child 클래스의 printName() 메서드 내부에서는 먼저 "Child 클래스의 메서드입니다."를 출력하고, 그 다음 this.name을 사용하여 현재 객체(Child 객체)의 name 필드 값을 출력합니다. 이 때 this.name은 Child 클래스에 정의된 name이므로 "child"가 출력됩니다.

<br></br>

### 3. 다형성의 개념에 대해 설명하고 아래 코드에 상속, 다형성을 적용해 보다 유지 보수하기 편하고, 유연한 코드로 만들어보세요(선민)
```java
class HoneyOat {
    String name = "HoneyOat";
}

class Wheat {
    String name = "Wheat";
}

class Bread {
}

class HoneyOatBurger {
    
    String name;
    
    HoneyOatBurger(HoneyOat honeyOat) {
        this.name = honeyOat.name;
    }
}

class WheatBurger {
    String name;
    
    WheatBurger(Wheat wheat) {
        this.name = wheat.name;
    }
}
```
힌트
1. 허니오트와 위트는 모두 빵의 한 종류입니다
2. 다형성을 잘 이용하면 빵 종류가 더 많아지더라도 버거 클래스가 늘어날 필요가 없어요!!

<br></br>

### 4. 다음 코드의 실행 결과를 설명하세요.(민아)
```java
class Card {
    final int NUMBER;
    final String KIND;
    static int width = 100;
    static int height = 250;

    Card(String kind, int num) {
        KIND = kind;
        NUMBER = num;
    }

    Card() {
        this("HEART", 1);
    }

    public String toString() {
        return KIND +" "+ NUMBER;
    }
}
class text {
    public static void main(String args[]) {
        Card c = new Card("HEART", 10);
        System.out.println(c.KIND);
        System.out.println(c.NUMBER);
        System.out.println(c);
    }
}
```
<br></br>

### 5. 제어자에 대한 설명 중 틀린 것은 무엇인가요?(민아)
1) 메서드에 static과 abstract를 함께 사용할 수 있다.
2) 클래스에 abstract와 final을 동시에 사용할 수 없다.
3) abstract메서드의 접근 제어자가 private일 수 없다.
4) 메서드에 private과 final을 같이 사용할 필요는 없다.


<br></br>

### 6. 다음 표의 빈 칸에 Vector 클래스의 주요 메서드를 채워주세요.(민아)
|메서드/생성자|설명|
|-|-|
||10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다. 10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가된다.|
||Vector에 객체를 추가한다. 추가에 성공하면 결과값으로 true, 실패하면 false를 반환한다.|
||Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환한다.|
||Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환한다.|
||지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로의 형변환이 필요하다.|
||Vector에 저장된 객체의 개수를 반환한다.|

<br></br>

### 7. private로 변수를 선언하고 getter, setter를 사용하는 이유를 설명하세요.(지영)

```java

class Time {
    private int hour;

    public void setHour(int h) {
        if (h < 0 || h > 23) return;
        hour = h;
    }

    public int getHour() {
        return hour;
    }
}

public class Problem07{
    public static void main(String[] args){
    Time t = new Time();
            t.setHour(3);
            System.out.println(t.getHour()); // 출력결과 : 3

    }

}
```

### 8. 다음 코드에서 에러가 발생하는 이유를 출력결과를 참고하여 설명하시오.(지영)

```java
class Car {
    String color;
    int door;
    void drive() {
        System.out.println("drive, brrrr!");
    }
}
class FireEngine extends Car{
    void water() {
        System.out.println("water!");
    }
}

public class Problem08{
    public static void main(String args []) {
        Car car = null;
        FireEngine fe = new FireEngine();
        FireEngine fe2 = null;

        car = fe;
        //fe2 = car; 에러 발생
        System.out.println(fe2 instanceof Car);
    }
}

```


### 9. 다음은 제어자를 조합해서 사용할 때 주의해야 할 사항입니다. 각 주의사항들을 왜 주의해야 하는지 설명하세요.(지영)

1. 메서드에 static과 abstract를 함께 사용할 수 없다.

2. 클래스에 abstract와 final을 동시에 사용할 수 없다.

3. abstract메서드의 접근 제어자가 private일 수 없다.

4. 메서드에 private과 final을 같이 사용할 필요는 없다.

### 10. static제어자에 대해 설명하세요.(성훈)

제어자 : 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여하는것
static : 클래스의, 공통적인 의미를 가짐
- 인스턴스 변수는 인스턴스마다 각기 다른 값을 유지하지만, 클래스 변수는 인스턴스에 관계없는 같은 값을 가짐
- 하나의 변수를 모든 인스턴스에서 공유
- 메서드도 동일
- 인스턴스 생성하지 않고도 호출 가능

<br>

### 11. 아래 코드의 실행결과를 설명하세요.(성훈)

```java
public class Main {
    public static void main(String[] args) {
        Singleton s = new Singleton();  //에러 발생
        Singleton s = Singleton.getlnstance();
    }
}
final class Singleton {
    private static Singleton s = new Singleton();
    private Singleton() {
       
    }
    public static Singleton getlnstance() {
        if (s == null)
            s = new Singleton();
        return s;
    }
}
```

<br>

### 12. 아래 코드의 실행결과를 설명하세요.(성훈)

```java
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        Car car2 = null;
        FireEngine fe = null;
        car.drive();
        fe = (FireEngine)car;
        fe.drive();
        car2 = fe;
        car2.drive();
    }
}
class Car {
    String color;
    int door;
    void drive() {
        System.out.println("drive, brrrr!");
    }
}
class FireEngine extends Car{
    void water() {
        System.out.println("water!");
    }
}
```
<br>

### 13. 자바의 일반적인 소스파일의 구성 순서 3가지를 말하시오.(기훈)

<br>

### 14. static import문을 사용했을때 얻을 수 있는 장점과 , 예시를 한가지 쓰시오.(기훈)

<br>

### 15. instanceof에 대해서 연산결과의 의미에 대해서 설명하시오.(기훈)

<br>

### 16. 패키지에 대한 설명으로 틀린 것은 무엇입니까?(현수)

1. 패키지는 클래스들을 그룹화시키는 기능을 한다.
2. 클래스가 패키지에 소속되려면 패키지 선언을 반드시 해야 한다.
3. import 문은 다른 패키지의 클래스를 사용할 때 필요하다.
4. com.mycom 패키지에 소속된 클래스는 com.yourcom에 옮겨 놓아도 동작한다.

<br>

### 17. 접근 제한에 대한 설명으로 틀린 것은 무엇입니까?(현수)

1. 접근 제한자는 클래스, 필드,, 생성자, 메소드의 사용을 제한한다.
2. public 접근 제한은 아무런 제한 없이 해당 요소를 사용할 수 있게 한다.
3. default 접근 제한은 해당 클래스 내부에서만 사용을 허가한다.
4. 외부에서 접근하지 못하도록 하려면 private 접근 제한을 해야 한다.

<br>

### 18. final 필드와 상수(static final)에 대한 설명으로 틀린 것은 무엇입니까?(현수)

1. final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다.
2. final 필드와 상수는 생성자에서 초기화될 수 있다.
3. 상수의 이름은 대문자로 작성하는 것이 관례이다.
4. 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.

