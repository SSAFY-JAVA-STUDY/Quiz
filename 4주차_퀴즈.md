### 1. 아래 코드의 결과와 그 이유를 설명해주세요(선민)
``` java
class A {
  A() {
    System.out.println("A 클래스 인스턴스 생성");
  }
}

class B extends A {
  B() {
    System.out.println("B 클래스 인스턴스 생성");
  }

  B(int num) {
    System.out.println("B 클래스 인스턴스 " + num + " 생성");
  }
}

class C extends B {
  C() {
    super(1);
    System.out.println("C 클래스 인스턴스 생성");
  }
}

public class Main {
    public static void main(String[] args) {
        B b = new C();
    }
}
```
<br>

### 2. "오버라이딩" 과 "오버로딩" 에 대해서 설명해주세요.(선민)
<br>

### 3. 클래스 변수와 멤버 변수의 초기화 시점 및 초기화 순서에 대해 설명해주세요.(선민)
<br>

### 4. 상속의 정의와 장점에 대해서 설명하시오.(기훈)
<br>

### 5. 다중 상속을 받을 수 있을때, 생기는 문제점에 대해 설명하시오.(기훈)
<br>

### 6. Object 클래스의 특징과 가지고있는 메서드 2가지에 대해 설명하시오.(기훈)
<br>

### 7. 멤버변수의 초기화 방법 3가지를 서술하세요.(민아)
- 명시적 초기화 : 멤버 변수를 선언하면서 동시에 초기값을 할당하는 방법
- 생성자 : 클래스의 인스턴스가 생성될 때 자동으로 호출되는 생성자를 사용해 초기화
- 초기화 블록 : 인스턴스 초기화 블록, 정적 초기화 블록을 사용
<br>

### 8. A, B, C에 들어갈 말을 서술하세요.(민아)
Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 A 또는 B를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 C를 생성자의 첫 줄에 삽입한다.
<br>

### 9. 오버로딩 성립을 위한 조건 2가지와 오버라이딩 성립을 위한 조건 3가지를 서술하세요.(민아)
<br>

### 10. 다음 코드에서 (1)에서는 에러가 발생하지 않는데 (2)에서는 에러가 발생하는 이유를 설명하세요. (지영)

```java
class Problem10{

    int x;
    int y = x; // (1)

    void method(){
        int i;
        int j = i; // (2) error 발생
    }

}
```

<br>

### 11. 해당 this가 호출하는 생성자는 무엇인가요?(지영)

```java
class Car{
    String color;
    String gearType;
    int door;
    
    Car(){
        this("white", "auto", 4); // 해당 this가 호출하는 생성자는?
    }
    
    Car(String color){ // 생성자 1
        this(color, "auto", 4);
    }
    
    Car(String color, String gearType){ // 생성자 2
        this(color, gearType, 4);
    }
    
    Car(String color, String gearType, int door){ // 생성자 3
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
    
}
```

<br>

### 12. 다음 출력 결과를 예측하고 그 이유를 설명하시오.(지영)

```java
public class Problem12 {
    public static void main(String[] args) {
        Product p1 = new Product();
        Product p2 = new Product();
        Product p3 = new Product();
        Product p4 = new Product();

        System.out.println(p2.count); 
    }
}

class Product{
    static int count = 0;
    {
        ++count;
    }
}

```

<br>

### 13. 현실 세계의 회원을 Member 클래스로 모델링하려고 합니다 회원의 데이터로는 이름, 아이디, 패스워드, 나이가 있습니다. 이 데이터들을 가지는 Member 클래스를 선언해보세요.(현수)

|데이터 이름|필드 이름|타입|
|------|---|---|
|이름|name|문자열|
|아이디|id|문자열|
|패스워드|password|문자열|
|나이|age|정수|

``` java
public class Member {
    // 필드 선언
    private String name;     // 이름
    private String id;       // 아이디
    private String password; // 패스워드
    private int age;         // 나이

    // 생성자
    public Member(String name, String id, String password, int age) {
        this.name = name;
        this.id = id;
        this.password = password;
        this.age = age;
    }

    // Getter 및 Setter 메서드
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```
<br>

### 14. 13번 문제에서 작성한 Member 클래스에 생성자를 추가하려고 합니다. 다음과 같이 name 필드와 id필드를 외부에서 받은 값으로 초기화하도록 생성자를 선언해보세요.(현수)

```java
Member user1 = new Member("홍길동", "hong");

```

<br>

### 15. 메소드 오버로딩에 대한 설명으로 틀린 것은 무엇입니까?(현수)

1) 동일한 이름의 메소드를 여러 개 선언하는 것을 말한다.
2) 반드시 리턴 타입이 달라야 한다.
3) 매개변수의 타입, 수, 순서를 다르게 선언해야 한다.
4) 매개값의 타입 및 수에 따라 호출될 메소드가 선택된다.

<br>

### 16. 다음 코드에서 오류가 발생하는 이유와 해결방안을 설명하세요.(성훈)
```java
class Data1 {
    int value;
}
class Data2 {
    int value;
    Data2(int x) {
        value = x;
    }
}

public class Main {
    public static void main(String[] args) {

        Data1 dl = new Data1();
        Data2 d2 = new Data2(); // compile error발생

    }
}
```

<br>

### 17. 클래스 포함관계의 정의와 장점에 대해 설명하세요.(성훈)
클래스 포함관계(composition)는 한 클래스가 다른 클래스를 포함하고 있는 관계를 말합니다. 이는 객체 지향 프로그래밍에서 두 클래스 간의 관계를 표현하는 방법 중 하나입니다. 포함관계는 주로 "has-a" 관계로 표현되며, 한 클래스가 다른 클래스의 객체를 멤버 변수로 가지는 구조를 의미합니다.

장점
코드 재사용성: 포함관계를 사용하면 기존에 구현된 클래스를 쉽게 재사용할 수 있습니다. 새로운 클래스를 작성할 때 기존 클래스의 기능을 포함하여 확장하거나 조합하여 사용할 수 있습니다.
모듈화와 유지보수성 향상: 포함관계를 사용하면 각 클래스가 담당하는 기능이 명확해져서 코드의 모듈화가 잘 이루어집니다. 이로 인해 코드의 유지보수가 쉬워집니다.
객체 지향 설계의 유연성: 클래스 간의 관계를 느슨하게 유지하면 객체 지향 설계의 유연성이 향상됩니다. 포함관계를 통해 각 클래스가 독립적으로 설계되고, 변경될 때 다른 클래스에 영향을 최소화할 수 있습니다.
<br>

### 18. 다음 두 코드의 실행결과와 참조변수 super와 this에 대해 설명하세요.(성훈)
```java
public class Main {
    public static void main(String[] args) {

        Child c = new Child();
        c.method();
    }
}

class Parent {
    int x=10;
}

class Child extends Parent {
    void method() {
        System.out.println("x=" + x);
        System.out.println("this.x="+ this.x);
        System.out.println("super.x="+ super.x);

    }
}
```

```java
public class Main {
    public static void main(String[] args) {

        Child c = new Child();
        c.method();
    }
}

class Parent {
    int x=10;
}

class Child extends Parent {
    int x=20;
    void method() {
        System.out.println("x=" + x);
        System.out.println("this.x="+ this.x);
        System.out.println("super.x="+ super.x);

    }
}
```

<br>